[
    {
        "topic": "Process Management",
        "question_no": "Question1",
        "question_text": "Consider the following code fragment:Cif(fork()==0){a=a+5;printf(\"%d,%d\\\\n\",a,&a);}else{a=a–5;printf(\"%d, %d\\\\n\",a,&a);}Let u, v be the values printed by the parent process, and x, y be the values printed by the child process. Which one of the following is TRUE?",
        "question_img_link": null,
        "options": [
            "u = x + 10 and v = y",
            "u = x + 10 and v != y",
            "u + 10 = x and v = y",
            "u + 10 = x and v != y"
        ],
        "correct_option": "u + 10 = x and v = y"
    },
    {
        "topic": "Process Management",
        "question_no": "Question2",
        "question_text": "The atomic fetch-and-set x, y instruction unconditionally sets the memory location x to 1 and fetches the old value of x in y without allowing any intervening access to the memory location x. consider the following implementation of P and V functions on a binary semaphore .void P (binary_semaphore *s) {\r\n  unsigned y;\r\n  unsigned *x = &(s->value);\r\n  do {\r\n     fetch-and-set x, y;\r\n  } while (y);\r\n}\r\n\r\nvoid V (binary_semaphore *s) {\r\n  S->value = 0;\r\n}Which one of the following is true?",
        "question_img_link": null,
        "options": [
            "The implementation may not work if context switching is disabled in P.",
            "Instead of using fetch-and-set, a pair of normal load/store can be used",
            "The implementation of V is wrong",
            "The code does not implement a binary semaphore"
        ],
        "correct_option": "The implementation may not work if context switching is disabled in P."
    },
    {
        "topic": "Process Management",
        "question_no": "Question3",
        "question_text": "A shared variable x, initialized to zero, is operated on by four concurrent processes W, X, Y, Z as follows. Each of the processes W and X reads x from memory, increments by one, stores it to memory, and then terminates. Each of the processes Y and Z reads x from memory, decrements by two, stores it to memory, and then terminates. Each process before reading x invokes the P operation (i.e., wait) on a counting semaphore S and invokes the V operation (i.e., signal) on the semaphore S after storing x to memory. Semaphore S is initialized to two. What is the maximum possible value of x after all processes complete execution? (GATE CS 2013)",
        "question_img_link": null,
        "options": [
            "-2",
            "-1",
            "1",
            "2"
        ],
        "correct_option": "2"
    },
    {
        "topic": "Process Management",
        "question_no": "Question4",
        "question_text": "A shared variable x, initialized to zero, is operated on by four concurrent processes W, X, Y, Z as follows. Each of the processes W and X reads x from memory, increments by one, stores it to memory, and then terminates. Each of the processes Y and Z reads x from memory, decrements by two, stores it to memory, and then terminates. Each process before reading x invokes the P operation (i.e., wait) on a counting semaphore S and invokes the V operation (i.e., signal) on the semaphore S after storing x to memory. Semaphore S is initialized to two. What is the maximum possible value of x after all processes complete execution? (GATE CS 2013)",
        "question_img_link": null,
        "options": [
            "-2",
            "-1",
            "1",
            "2"
        ],
        "correct_option": "2"
    },
    {
        "topic": "Process Management",
        "question_no": "Question5",
        "question_text": "A certain computation generates two arrays a and b such that a[i]=f(i) for 0 ≤ i < n and b[i]=g(a[i]) for 0 ≤ i < n. Suppose this computation is decomposed into two concurrent processes X and Y such that X computes the array a and Y computes the array b. The processes employ two binary semaphores R and S, both initialized to zero. The array a is shared by the two processes. The structures of the processes are shown below.Process X:Process Y:private i;                         private i;\r\nfor (i=0; i < n; i++) {            for (i=0; i < n; i++) {\r\n   a[i] = f(i);                       EntryY(R, S);\r\n   ExitX(R, S);                       b[i]=g(a[i]);\r\n}                                 }Which one of the following represents the CORRECT implementations of ExitX and EntryY?(A)ExitX(R, S) {\r\n  P(R);\r\n  V(S);\r\n}\r\n\r\nEntryY (R, S) {\r\n  P(S);\r\n  V(R);\r\n}(B)ExitX(R, S) {\r\n  V(R);\r\n  V(S);\r\n}\r\n\r\nEntryY(R, S) {\r\n  P(R);\r\n  P(S);\r\n}(C)ExitX(R, S) {\r\n  P(S);\r\n  V(R);\r\n}\r\nEntryY(R, S) {\r\n  V(S);\r\n  P(R);\r\n}(D)ExitX(R, S) {\r\n  V(R);\r\n  P(S);\r\n}\r\nEntryY(R, S) {\r\n  V(S);\r\n  P(R);\r\n}",
        "question_img_link": null,
        "options": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct_option": "C"
    },
    {
        "topic": "Process Management",
        "question_no": "Question6",
        "question_text": "Three concurrent processes X, Y, and Z execute three different code segments that access and update certain shared variables. Process X executes the P operation (i.e., wait) on semaphores a, b and c; process Y executes the P operation on semaphores b, c and d; process Z executes the P operation on semaphores c, d, and a before entering the respective code segments. After completing the execution of its code segment, each process invokes the V operation (i.e., signal) on its three semaphores. All semaphores are binary semaphores initialized to one. Which one of the following represents a deadlock-free order of invoking the P operations by the processes?",
        "question_img_link": null,
        "options": [
            "X: P(a)P(b)P(c) Y: P(b)P(c)P(d) Z: P(c)P(d)P(a)",
            "X: P(b)P(a)P(c) Y: P(b)P(c)P(d) Z: P(a)P(c)P(d)",
            "X: P(b)P(a)P(c) Y: P(c)P(b)P(d) Z: P(a)P(c)P(d)",
            "X: P(a)P(b)P(c) Y: P(c)P(b)P(d) Z: P(c)P(d)P(a)"
        ],
        "correct_option": "X: P(b)P(a)P(c) Y: P(b)P(c)P(d) Z: P(a)P(c)P(d)"
    },
    {
        "topic": "Process Management",
        "question_no": "Question7",
        "question_text": "A shared variable x, initialized to zero, is operated on by four concurrent processes W, X, Y, Z as follows. Each of the processes W and X reads x from memory, increments by one, stores it to memory, and then terminates. Each of the processes Y and Z reads x from memory, decrements by two, stores it to memory, and then terminates. Each process before reading x invokes the P operation (i.e., wait) on a counting semaphore S and invokes the V operation (i.e., signal) on the semaphore S after storing x to memory. Semaphore S is initialized to two. What is the maximum possible value of x after all processes complete execution?",
        "question_img_link": null,
        "options": [
            "-2",
            "-1",
            "1",
            "2"
        ],
        "correct_option": "2"
    },
    {
        "topic": "Process Management",
        "question_no": "Question8",
        "question_text": "A certain computation generates two arrays a and b such that a[i]=f(i) for 0 ≤ i < n and b[i]=g(a[i]) for 0 ≤ i < n. Suppose this computation is decomposed into two concurrent processes X and Y such that X computes the array a and Y computes the array b. The processes employ two binary semaphores R and S, both initialized to zero. The array a is shared by the two processes. The structures of the processes are shown below.Process X:Process Y:private i;                         private i;\r\nfor (i=0; i < n; i++) {            for (i=0; i < n; i++) {\r\n   a[i] = f(i);                       EntryY(R, S);\r\n   ExitX(R, S);                       b[i]=g(a[i]);\r\n}                                 }Which one of the following represents the CORRECT implementations of ExitX and EntryY?(A)ExitX(R, S) {\r\n  P(R);\r\n  V(S);\r\n}\r\n\r\nEntryY (R, S) {\r\n  P(S);\r\n  V(R);\r\n}(B)ExitX(R, S) {\r\n  V(R);\r\n  V(S);\r\n}\r\n\r\nEntryY(R, S) {\r\n  P(R);\r\n  P(S);\r\n}(C)ExitX(R, S) {\r\n  P(S);\r\n  V(R);\r\n}\r\nEntryY(R, S) {\r\n  V(S);\r\n  P(R);\r\n}(D)ExitX(R, S) {\r\n  V(R);\r\n  P(S);\r\n}\r\nEntryY(R, S) {\r\n  V(S);\r\n  P(R);\r\n}",
        "question_img_link": null,
        "options": [
            "A",
            "B",
            "C",
            "D"
        ],
        "correct_option": "C"
    },
    {
        "topic": "Process Management",
        "question_no": "Question9",
        "question_text": "A process executes the codefork();\r\nfork();\r\nfork();The total number of child processes created is",
        "question_img_link": null,
        "options": [
            "3",
            "4",
            "7",
            "8"
        ],
        "correct_option": "7"
    },
    {
        "topic": "Process Management",
        "question_no": "Question10",
        "question_text": "Fetch_And_Add(X,i) is an atomic Read-Modify-Write instruction that reads the value of memory location X, increments it by the value i, and returns the old value of X. It is used in the pseudocode shown below to implement a busy-wait lock. L is an unsigned integer shared variable initialized to 0. The value of 0 corresponds to lock being available, while any non-zero value corresponds to the lock being not available.AcquireLock(L){\r\n         while (Fetch_And_Add(L,1))\r\n               L = 1;\r\n   }\r\n  ReleaseLock(L){\r\n         L = 0;\r\n   }This implementation",
        "question_img_link": null,
        "options": [
            "fails as L can overflow",
            "fails as L can take on a non-zero value when the lock is actually available",
            "works correctly but may starve some processes",
            "works correctly without starvation"
        ],
        "correct_option": "fails as L can take on a non-zero value when the lock is actually available"
    },
    {
        "topic": "Process Management",
        "question_no": "Question11",
        "question_text": "The time taken to switch between user and kernel modes of execution be t1 while the time taken to switch between two processes be t2. \r\n\r\nWhich of the following is TRUE?",
        "question_img_link": null,
        "options": [
            "t1 > t2",
            "t1 = t2",
            "t1 < t2",
            "nothing can be said about the relation between t1 and t2"
        ],
        "correct_option": "t1 < t2"
    },
    {
        "topic": "Process Management",
        "question_no": "Question12",
        "question_text": "A thread is usually defined as a \"light weight process\" because an operating system (OS) maintains smaller data structures for a thread than for a process. In relation to this, which of the following is TRUE?",
        "question_img_link": null,
        "options": [
            "On per-thread basis, the OS maintains only CPU register state",
            "The OS does not maintain a separate stack for each thread",
            "On per-thread basis, the OS does not maintain virtual memory state",
            "On per-thread basis, the OS maintains only scheduling and accounting information"
        ],
        "correct_option": "On per-thread basis, the OS does not maintain virtual memory state"
    },
    {
        "topic": "Process Management",
        "question_no": "Question13",
        "question_text": "Consider the methods used by processes P1 and P2 for accessing their critical sections whenever needed, as given below. The initial values of shared boolean variables S1 and S2 are randomly assigned.Method Used by P1\r\nwhile (S1 == S2) ;\r\nCritica1 Section\r\nS1 = S2;\r\n\r\nMethod Used by P2\r\nwhile (S1 != S2) ;\r\nCritica1 Section\r\nS2 = not (S1);Which one of the following statements describes the properties achieved?",
        "question_img_link": null,
        "options": [
            "Mutual exclusion but not progress",
            "Progress but not mutual exclusion",
            "Neither mutual exclusion nor progress",
            "Both mutual exclusion and progress"
        ],
        "correct_option": "Mutual exclusion but not progress"
    },
    {
        "topic": "Process Management",
        "question_no": "Question14",
        "question_text": "The following program consists of 3 concurrent processes and 3 binary semaphores.The semaphores are initialized as S0 = 1, S1 = 0, S2 = 0.How many times will process P0 print '0'?",
        "question_img_link": "http://www.geeksforgeeks.org/wp-content/uploads/gq/2013/12/gatecs201042.png",
        "options": [
            "At least twice",
            "Exactly twice",
            "Exactly thrice",
            "Exactly once"
        ],
        "correct_option": "At least twice"
    },
    {
        "topic": "Process Management",
        "question_no": "Question15",
        "question_text": "The enter_CS() and leave_CS() functions to implement critical section of a process are realized using test-and-set instruction as follows:void enter_CS(X)\r\n{\r\n    while test-and-set(X) ;\r\n}\r\nvoid leave_CS(X)\r\n{\r\n   X = 0;\r\n}In the above solution, X is a memory location associated with the CS and is initialized to 0. Now consider the following statements:\r\nI. The above solution to CS problem is deadlock-free\r\nII. The solution is starvation free.\r\nIII. The processes enter CS in FIFO order.\r\nIV More than one process can enter CS at the same time.\r\n\r\nWhich of the above statements is TRUE?",
        "question_img_link": null,
        "options": [
            "I only",
            "I and II",
            "II and III",
            "IV only"
        ],
        "correct_option": "I only"
    },
    {
        "topic": "Process Management",
        "question_no": "Question16",
        "question_text": "The P and V operations on counting semaphores, where s is a counting semaphore, are defined as follows:P(s) : s =  s - 1;\r\n  if (s  < 0) then wait;\r\nV(s) : s = s + 1;\r\n  if (s <= 0) then wakeup a process waiting on s;Assume that Pb and Vb the wait and signal operations on binary semaphores are provided. Two binary semaphores Xb and Yb are used to implement the semaphore operations P(s) and V(s) as follows:P(s) : Pb(Xb);\r\n  s = s - 1;\r\n  if (s < 0) {\r\n   Vb(Xb) ;\r\n   Pb(Yb) ;\r\n  }\r\n  else Vb(Xb); \r\n\r\nV(s) : Pb(Xb) ;\r\n  s = s + 1;\r\n  if (s <= 0) Vb(Yb) ;\r\n  Vb(Xb) ;The initial values of Xb and Yb are respectively",
        "question_img_link": null,
        "options": [
            "0 and 0",
            "0 and 1",
            "1 and 0",
            "1 and 1"
        ],
        "correct_option": "1 and 0"
    },
    {
        "topic": "Process Management",
        "question_no": "Question17",
        "question_text": "A process executes the following codefor (i = 0; i < n; i++) fork();The total number of child processes created is",
        "question_img_link": null,
        "options": [
            "n",
            "2n- 1",
            "2n",
            "2(n+1)- 1"
        ],
        "correct_option": "2n - 1"
    },
    {
        "topic": "Process Management",
        "question_no": "Question18",
        "question_text": "Consider the following statements about user level threads and kernel level threads. Which one of the following statement is FALSE?",
        "question_img_link": null,
        "options": [
            "Context switch time is longer for kernel level threads than for user level threads.",
            "User level threads do not need any hardware support.",
            "Related kernel level threads can be scheduled on different processors in a multi-processor system.",
            "Blocking one kernel level thread blocks all related threads."
        ],
        "correct_option": "Blocking one kernel level thread blocks all related threads."
    },
    {
        "topic": "Process Management",
        "question_no": "Question19",
        "question_text": "Two processes, P1 and P2, need to access a critical section of code. Consider the following synchronization construct used by the processes:Here, wants1 and wants2 are shared variables, which are initialized to false. Which one of the following statements is TRUE about the above construct?v/* P1 */\r\nwhile (true) {\r\n  wants1 = true;\r\n  while (wants2 == true);\r\n  /* Critical\r\n    Section */\r\n  wants1=false;\r\n}\r\n/* Remainder section */       \r\n\r\n\r\n/* P2 */\r\nwhile (true) {\r\n  wants2 = true;\r\n  while (wants1==true);\r\n  /* Critical\r\n    Section */\r\n  wants2 = false;\r\n}\r\n/* Remainder section */",
        "question_img_link": null,
        "options": [
            "It does not ensure mutual exclusion.",
            "It does not ensure bounded waiting.",
            "It requires that processes enter the critical section in strict alternation.",
            "It does not prevent deadlocks, but ensures mutual exclusion."
        ],
        "correct_option": "It does not prevent deadlocks, but ensures mutual exclusion."
    },
    {
        "topic": "Process Management",
        "question_no": "Question20",
        "question_text": "Which one of the following is FALSE?",
        "question_img_link": null,
        "options": [
            "User level threads are not scheduled by the kernel.",
            "When a user level thread is blocked, all other threads of its process are blocked.",
            "Context switching between user level threads is faster than context switching between kernel level threads.",
            "Kernel level threads cannot share the code segment"
        ],
        "correct_option": "Kernel level threads cannot share the code segment"
    },
    {
        "topic": "Process Management",
        "question_no": "Question21",
        "question_text": "Consider two processors P1 and P2 executing the same instruction set. Assume that under identical conditions, for the same input, a program running on P2 takes 25% less time but incurs 20% more CPI (clock cycles per instruction) as compared to the program running on P1. If the clock frequency of P1 is 1GHz, then the clock frequency of P2 (in GHz) is _________.",
        "question_img_link": null,
        "options": [
            "1.6",
            "3.2",
            "1.2",
            "0.8"
        ],
        "correct_option": "1.6"
    },
    {
        "topic": "Process Management",
        "question_no": "Question22",
        "question_text": "Consider the procedure below for the Producer-Consumer problem which uses semaphores:Which one of the following is TRUE?",
        "question_img_link": "http://www.geeksforgeeks.org/wp-content/uploads/gq/2014/04/GATECS2014Q30.png",
        "options": [
            "The producer will be able to add an item to the buffer, but the consumer can never consume it.",
            "The consumer will remove no more than one item from the buffer.",
            "Deadlock occurs if the consumer succeeds in acquiring semaphore s when the buffer is empty.",
            "The starting value for the semaphore n must be 1 and not 0 for deadlock-free operation."
        ],
        "correct_option": "Deadlock occurs if the consumer succeeds in acquiring semaphore s when the buffer is empty."
    },
    {
        "topic": "Process Management",
        "question_no": "Question23",
        "question_text": "The atomic fetch-and-set x, y instruction unconditionally sets the memory location x to 1 and fetches the old value of x n y without allowing any intervening access to the memory location x. consider the following implementation of P and V functions on a binary semaphore S.void P (binary_semaphore *s)\r\n{\r\n    unsigned y;\r\n    unsigned *x = &(s->value);\r\n    do\r\n    {\r\n        fetch-and-set x, y;\r\n    }\r\n    while (y);\r\n}\r\nvoid V (binary_semaphore *s)\r\n{\r\n    S->value = 0;\r\n}Which one of the following is true?",
        "question_img_link": null,
        "options": [
            "The implementation may not work if context switching is disabled in P",
            "Instead of using fetch-and –set, a pair of normal load/store can be used",
            "The implementation of V is wrong",
            "The code does not implement a binary semaphore"
        ],
        "correct_option": "The implementation may not work if context switching is disabled in P"
    },
    {
        "topic": "Process Management",
        "question_no": "Question24",
        "question_text": "Barrier is a synchronization construct where a set of processes synchronizes globally i.e. each process in the set arrives at the barrier and waits for all others to arrive and then all processes leave the barrier. Let the number of processes in the set be three and S be a binary semaphore with the usual P and V functions. Consider the following C implementation of a barrier with line numbers shown on left.Cvoidbarrier(void){1:P(S);2:process_arrived++;3.V(S);4:while(process_arrived!=3);5:P(S);6:process_left++;7:if(process_left==3){8:process_arrived=0;9:process_left=0;10:}11:V(S);}The variables process_arrived and process_left are shared among all processes and are initialized to zero. In a concurrent program all the three processes call the barrier function when they need to synchronize globally.\r\n\r\nThe above implementation of barrier is incorrect. Which one of the following is true?",
        "question_img_link": null,
        "options": [
            "The barrier implementation is wrong due to the use of binary semaphore S",
            "The barrier implementation may lead to a deadlock if two barrier in\rinvocations are used in immediate succession.",
            "Lines 6 to 10 need not be inside a critical section",
            "The barrier implementation is correct if there are only two processes instead of three."
        ],
        "correct_option": "The barrier implementation may lead to a deadlock if two barrier in invocations are used in immediate succession."
    },
    {
        "topic": "Process Management",
        "question_no": "Question25",
        "question_text": "Barrier is a synchronization construct where a set of processes synchronizes globally i.e. each process in the set arrives at the barrier and waits for all others to arrive and then all processes leave the barrier. Let the number of processes in the set be three and S be a binary semaphore with the usual P and V functions. Consider the following C implementation of a barrier with line numbers shown on left.Cvoidbarrier(void){1:P(S);2:process_arrived++;3.V(S);4:while(process_arrived!=3);5:P(S);6:process_left++;7:if(process_left==3){8:process_arrived=0;9:process_left=0;10:}11:V(S);}The variables process_arrived and process_left are shared among all processes and are initialized to zero. In a concurrent program all the three processes call the barrier function when they need to synchronize globally.\r\n\r\nWhich one of the following rectifies the problem in the implementation?",
        "question_img_link": null,
        "options": [
            "Lines 6 to 10 are simply replaced by process_arrived--",
            "At the beginning of the barrier the first process to enter the barrier waits\runtil process_arrived becomes zero before proceeding to execute P(S).",
            "Context switch is disabled at the beginning of the barrier and re-enabled at the end.",
            "The variable process_left is made private instead of shared"
        ],
        "correct_option": "At the beginning of the barrier the first process to enter the barrier waits until process_arrived becomes zero before proceeding to execute P(S)."
    },
    {
        "topic": "Process Management",
        "question_no": "Question26",
        "question_text": "Consider two processes P1 and P2 accessing the shared variables X and Y protected by two binary semaphores SX and SY respectively, both initialized to 1. P and V denote the usual semaphore operators, where P decrements the semaphore value, and V increments the semaphore value. The pseudo-code of P1 and P2 is as follows : P1 :",
        "question_img_link": null,
        "options": [
            "P(SY), P(SX); P(SX), P(SY)",
            "P(SX), P(SY); P(SY), P(SX)",
            "P(SX), P(SX); P(SY), P(SY)",
            "P(SX), P(SY); P(SX), P(SY)"
        ],
        "correct_option": "P(SX), P(SY); P(SX), P(SY)"
    },
    {
        "topic": "Process Management",
        "question_no": "Question27",
        "question_text": "Suppose we want to synchronize two concurrent processes P and Q using binary semaphores S and T. The code for the processes P and Q is shown below.Process P:while (1) {\r\nW:\r\n   print '0';\r\n   print '0';\r\nX:\r\n}Process Q:while (1) {\r\nY:\r\n   print '1';\r\n   print '1';\r\nZ:\r\n}Synchronization statements can be inserted only at points W, X, Y and Z.Which of the following will always lead to an output starting with '001100110011' ?",
        "question_img_link": null,
        "options": [
            "P(S) at W, V(S) at X, P(T) at Y, V(T) at Z, S and T initially 1",
            "P(S) at W, V(T) at X, P(T) at Y, V(S) at Z, S initially 1, and T initially 0",
            "P(S) at W, V(T) at X, P(T) at Y, V(S) at Z, S and T initially 1",
            "P(S) at W, V(S) at X, P(T) at Y, V(T) at Z, S initially 1, and T initially 0"
        ],
        "correct_option": "P(S) at W, V(T) at X, P(T) at Y, V(S) at Z, S initially 1, and T initially 0"
    },
    {
        "topic": "Process Management",
        "question_no": "Question28",
        "question_text": "Suppose we want to synchronize two concurrent processes P and Q using binary semaphores S and T. The code for the processes P and Q is shown below.Process P:while (1) {\r\nW:\r\n   print '0';\r\n   print '0';\r\nX:\r\n}Process Q:while (1) {\r\nY:\r\n   print '1';\r\n   print '1';\r\nZ:\r\n}Synchronization statements can be inserted only at points W, X, Y and Z\r\n\r\nWhich of the following will ensure that the output string never contains a substring of the form 01^n0 or 10^n1 where n is odd?",
        "question_img_link": null,
        "options": [
            "P(S) at W, V(S) at X, P(T) at Y, V(T) at Z, S and T initially 1",
            "P(S) at W, V(T) at X, P(T) at Y, V(S) at Z, S and T initially 1",
            "P(S) at W, V(S) at X, P(S) at Y, V(S) at Z, S initially 1",
            "V(S) at W, V(T) at X, P(S) at Y, P(T) at Z, S and T initially 1"
        ],
        "correct_option": "P(S) at W, V(S) at X, P(S) at Y, V(S) at Z, S initially 1"
    },
    {
        "topic": "Process Management",
        "question_no": "Question29",
        "question_text": "Which of the following does not interrupt a running process?",
        "question_img_link": null,
        "options": [
            "A device",
            "Timer",
            "Scheduler process",
            "Power failure"
        ],
        "correct_option": "Scheduler process"
    },
    {
        "topic": "Process Management",
        "question_no": "Question30",
        "question_text": "Which of the following need not necessarily be saved on a context switch between processes?",
        "question_img_link": null,
        "options": [
            "General purpose registers",
            "Translation look aside buffer",
            "Program counter",
            "All of the above"
        ],
        "correct_option": "Translation look aside buffer"
    },
    {
        "topic": "Process Management",
        "question_no": "Question31",
        "question_text": "The following two functions P1 and P2 that share a variable B with an initial value of 2 execute concurrently.P1() \r\n{ \r\n   C = B – 1; \r\n   B = 2*C;  \r\n}\r\n\r\nP2()\r\n{\r\n   D = 2 * B;\r\n   B = D - 1; \r\n}The number of distinct values that B can possibly take after the execution is",
        "question_img_link": null,
        "options": [
            "3",
            "2",
            "5",
            "4"
        ],
        "correct_option": "3"
    },
    {
        "topic": "Process Management",
        "question_no": "Question32",
        "question_text": "Two processes X and Y need to access a critical section. Consider the following synchronization construct used by both the processes.Here, varP and varQ are shared variables and both are initialized to false. Which one of the following statements is true?",
        "question_img_link": "http://www.geeksforgeeks.org/wp-content/uploads/gq/2015/02/Q20.png",
        "options": [
            "The proposed solution prevents deadlock but fails to guarantee mutual exclusion",
            "The proposed solution guarantees mutual exclusion but fails to prevent deadlock",
            "The proposed solution guarantees mutual exclusion and prevents deadlock",
            "The proposed solution fails to prevent deadlock and fails to guarantee mutual exclusion"
        ],
        "correct_option": "The proposed solution prevents deadlock but fails to guarantee mutual exclusion"
    },
    {
        "topic": "Process Management",
        "question_no": "Question33",
        "question_text": "In a certain operating system, deadlock prevention is attempted using the following scheme. Each process is assigned a unique timestamp, and is restarted with the same timestamp if killed. Let Ph be the process holding a resource R, Pr be a process requesting for the same resource R, and T(Ph) and T(Pr) be their timestamps respectively. The decision to wait or preempt one of the processes is based on the following algorithm.if T(Pr) < T(Ph)\r\n\r\n     then kill Pr\r\n\r\nelse waitWhich one of the following is TRUE?",
        "question_img_link": null,
        "options": [
            "The scheme is deadlock-free, but not starvation-free",
            "The scheme is not deadlock-free, but starvation-free",
            "The scheme is neither deadlock-free nor starvation-free",
            "The scheme is both deadlock-free and starvation-free"
        ],
        "correct_option": "The scheme is deadlock-free, but not starvation-free"
    },
    {
        "topic": "Process Management",
        "question_no": "Question34",
        "question_text": "A process executes the following segment of code :for(i = 1; i < = n; i++)\r\n\r\nfork ();The number of new processes created is",
        "question_img_link": null,
        "options": [
            "n",
            "((n(n + 1))/2)",
            "2n- 1",
            "3n- 1"
        ],
        "correct_option": "2n - 1"
    },
    {
        "topic": "Process Management",
        "question_no": "Question35",
        "question_text": "The semaphore variables full, empty and mutex are initialized to 0, n and 1, respectively. Process P1repeatedly adds one item at a time to a buffer of size n, and process P2repeatedly removes one item at a time from the same buffer using the programs given below. In the programs, K, L, M and N are unspecified statements.P1while (1) {K;P(mutex);\r\n\r\nAdd an item to the buffer;\r\n\r\nV(mutex);L;}P2while (1) {M;P(mutex);\r\n\r\nRemove an item from the buffer;\r\n\r\nV(mutex);N;}\r\n\r\nThe statements K, L, M and N are respectively",
        "question_img_link": null,
        "options": [
            "P(full), V(empty), P(full), V(empty)",
            "P(full), V(empty), P(empty), V(full)",
            "P(empty), V(full), P(empty), V(full)",
            "P(empty), V(full), P(full), V(empty)"
        ],
        "correct_option": "P(empty), V(full), P(full), V(empty)"
    },
    {
        "topic": "Process Management",
        "question_no": "Question36",
        "question_text": "Consider the following two-process synchronization solution.Process 0Process 1Entry: loop while (turn == 1);        Entry: loop while (turn == 0);\r\n       (critical section)                    (critical section)\r\n       Exit: turn = 1;                       Exit turn = 0;The shared variable turn is initialized to zero. Which one of the following is TRUE?",
        "question_img_link": null,
        "options": [
            "This is a correct two-process synchronization solution.",
            "This solution violates mutual exclusion requirement.",
            "This solution violates progress requirement.",
            "This solution violates bounded wait requirement."
        ],
        "correct_option": "This solution violates progress requirement."
    },
    {
        "topic": "Process Management",
        "question_no": "Question37",
        "question_text": "Consider a non-negative counting semaphore S. The operation P(S) decrements S, and V(S) increments S. During an execution, 20 P(S) operations and 12 V(S) operations are issued in some order. The largest initial value of S for which at least one P(S) operation will remain blocked is ________.",
        "question_img_link": null,
        "options": [
            "7",
            "8",
            "9",
            "10"
        ],
        "correct_option": "7"
    },
    {
        "topic": "Process Management",
        "question_no": "Question38",
        "question_text": "In the working-set strategy, which of the following is done by the operating system to prevent thrashing?It initiates another process if there are enough extra frames.It selects a process to suspend if the sum of the sizes of the working-sets exceeds the total number of available frames.",
        "question_img_link": null,
        "options": [
            "It initiates another process if there are enough extra frames.",
            "It selects a process to suspend if the sum of the sizes of the working-sets exceeds the total number of available frames.",
            "I only",
            "II only",
            "Neither I nor II",
            "Both I and II"
        ],
        "correct_option": "null"
    },
    {
        "topic": "Process Management",
        "question_no": "Question39",
        "question_text": "The following is a code with two threads, producer and consumer, that can run in parallel. Further, S and Q are binary semaphores equipped with the standard P and V operations.",
        "question_img_link": null,
        "options": [
            "The process can deadlock",
            "One of the threads can starve",
            "Some of the items produced by the producer may be lost",
            "Values generated and stored in 'x' by the producer will always be consumed before the producer can generate a new value"
        ],
        "correct_option": "Values generated and stored in 'x' by the producer will always be consumed before the producer can generate a new value"
    },
    {
        "topic": "Process Management",
        "question_no": "Question40",
        "question_text": "An operating system implements a policy that requires a process to release all resources before making a request for another resource. Select the TRUE statement from the following:",
        "question_img_link": null,
        "options": [
            "Both starvation and deadlock can occur",
            "Starvation can occur but deadlock cannot occur",
            "Starvation cannot occur but deadlock can occur",
            "Neither starvation nor deadlock can occur"
        ],
        "correct_option": "Starvation can occur but deadlock cannot occur"
    },
    {
        "topic": "Process Management",
        "question_no": "Question41",
        "question_text": "If the time-slice used in the round-robin scheduling policy is more than the maximum time required to execute any process, then the policy will",
        "question_img_link": null,
        "options": [
            "degenerate to shortest job first",
            "degenerate to priority scheduling",
            "degenerate to first come first serve",
            "none of the above"
        ],
        "correct_option": "degenerate to first come first serve"
    },
    {
        "topic": "Process Management",
        "question_no": "Question42",
        "question_text": "Consider the following C code for process P1 and P2. a=4, b=0, c=0 (initialization)P1                      P2\r\n  if (a < 0)                b = 10;    \r\n    c = b-a;                a = -3;\r\n  else\r\n    c = b+a;If the processes P1 and P2 executes concurrently (shared variables a, b and c), which of the following cannot be the value of ‘c’ after both processes complete?",
        "question_img_link": null,
        "options": [
            "4",
            "7",
            "10",
            "13"
        ],
        "correct_option": "10"
    },
    {
        "topic": "Process Management",
        "question_no": "Question43",
        "question_text": "Which of the following actions is/are typically not performed by the operating system when switching context from process A to process B?",
        "question_img_link": null,
        "options": [
            "Saving current register values and restoring saved register values for process B.",
            "Changing address translation tables.",
            "Swapping out the memory image of process A to the disk.",
            "Invalidating the translation look-aside buffer."
        ],
        "correct_option": "Swapping out the memory image of process A to the disk."
    },
    {
        "topic": "Process Management",
        "question_no": "Question44",
        "question_text": "In a computer system where the 'best-fit' algorithm is used for allocating 'jobs' to 'memory partitions', the following situation was encountered:When will the 20K job complete?Note -This question was subjective type.",
        "question_img_link": "http://www.cdn.geeksforgeeks.org/wp-content/uploads/tabkle.png",
        "options": [
            "8",
            "18",
            "11",
            "None of these"
        ],
        "correct_option": "None of these"
    },
    {
        "topic": "Process Management",
        "question_no": "Question45",
        "question_text": "A concurrent system consists of 3 processes using a shared resource R in a non-preemptible and mutually exclusive manner. The processes have unique priorities in the range 1.....3, 3 being the highest priority. It is required to synchronize the processes such that the resource is always allocated to the highest priority requester. The pseudo code for the system is as follows.Shared Datamutex:semaphore = 1:/* initialized to 1*/\r\nprocess[3]:semaphore = 0; /*all initialized to 0 */\r\nR_requested [3]:boolean = false; /*all initialized to false */\r\nbusy: boolean = false; /*initialized to false */Code for processesbegin process\r\nmy-priority:integer;\r\nmy-priority:=____; /*in the range 1...3*/\r\nrepeat\r\n    request_R(my-priority);\r\n    P (proceed [my-priority]);\r\n    {use shared resource R}\r\n    release_R (my-priority);\r\nforever\r\nend process;Proceduresprocedure request_R(priority);\r\nP(mutex);\r\nif busy = true then\r\n    R_requested [priority]:=true;\r\nelse\r\n begin\r\n    V(proceed [priority]);\r\n    busy:=true;\r\n end\r\nV(mutex);Give the pseudo code for the procedurerelease_R.",
        "question_img_link": null,
        "options": [],
        "correct_option": "null"
    },
    {
        "topic": "Process Management",
        "question_no": "Question46",
        "question_text": "The process state transition diagram in below figure is representative of",
        "question_img_link": "http://www.cdn.geeksforgeeks.org/wp-content/uploads/Untitled-Diagram.jpg",
        "options": [
            "a batch operating system",
            "an operating system with a preemptive schedular",
            "an operating system with a non-preemptive schedular",
            "a uni-programmed operating system"
        ],
        "correct_option": "an operating system with a preemptive schedular"
    },
    {
        "topic": "Process Management",
        "question_no": "Question47",
        "question_text": "Which of the following option is False?",
        "question_img_link": null,
        "options": [
            "An executing instance of a program is called a process while a thread is a subset of the process.",
            "Threads have considerable overhead while processes have almost no overhead.",
            "Execution of processes are independent while execution of threads are dependent.",
            "New processes require duplication of the parent process while new threads are easily created."
        ],
        "correct_option": "Threads have considerable overhead while processes have almost no overhead."
    },
    {
        "topic": "Process Management",
        "question_no": "Question48",
        "question_text": "Which of the following is/are not shared by all the threads in a process?I. Program Counter\r\n\r\nII. Stack\r\n\r\nIII. Registers\r\n\r\nIV. Address space",
        "question_img_link": null,
        "options": [
            "I and II only",
            "II and III only",
            "I, II and III only",
            "IV only"
        ],
        "correct_option": "I, II and III only"
    },
    {
        "topic": "Process Management",
        "question_no": "Question49",
        "question_text": "Consider the set of processes with arrival time(in milliseconds), CPU burst time (in milliseconds), and priority(0 is the highest priority) shown below. None of the processes have I/O burst time.The waiting time (in milliseconds) of process P1 using preemptive priority scheduling algorithm is ____.",
        "question_img_link": "https://cdncontribute.geeksforgeeks.org/wp-content/uploads/gate-46.png",
        "options": [
            "26",
            "49",
            "38",
            "29"
        ],
        "correct_option": "38"
    },
    {
        "topic": "Process Management",
        "question_no": "Question50",
        "question_text": "The following are some events that occur after a device controller issues an interrupt while process L is under execution.\r\n\r\n(P) The processor pushes the process status of L onto the control stack.\r\n(Q) The processor finishes the execution of the current instruction.\r\n(R) The processor executes the interrupt service routine.\r\n(S) The processor pops the process status of L from the control stack.\r\n(T) The processor loads the new PC value based on the interrupt.\r\n\r\nWhich of the following is the correct order in the which the events above occur?",
        "question_img_link": null,
        "options": [
            "QPTRS",
            "PTRSQ",
            "TRPQS",
            "QTPRS"
        ],
        "correct_option": "QPTRS"
    },
    {
        "topic": "Process Management",
        "question_no": "Question51",
        "question_text": "Two atomic operations permissible on Semaphores are __________ and __________.",
        "question_img_link": null,
        "options": [
            "wait, stop",
            "wait, hold",
            "hold, signal",
            "wait, signal"
        ],
        "correct_option": "wait, signal"
    },
    {
        "topic": "Process Management",
        "question_no": "Question52",
        "question_text": "Consider three CPU intensive processes, which require 10, 20, 30 units and arrive at times 0, 2, 6 respectively. How many context switches are needed if shortest remaining time first is implemented? Context switch at 0 is included but context switch at end is ignored",
        "question_img_link": null,
        "options": [
            "1",
            "2",
            "3",
            "4"
        ],
        "correct_option": "3"
    },
    {
        "topic": "Process Management",
        "question_no": "Question53",
        "question_text": "A process executes the following codefor (i = 0; i < n; i++) fork( );The total number of child processes created are",
        "question_img_link": null,
        "options": [
            "n2",
            "2n+1-1",
            "2n",
            "2n-1"
        ],
        "correct_option": "2n -1"
    },
    {
        "topic": "Process Management",
        "question_no": "Question54",
        "question_text": "Which of the following is false?",
        "question_img_link": null,
        "options": [
            "User level threads are not scheduled by the kernel",
            "Context switching between user level threads is faster than context switching between kernel level threads",
            "When a user thread is blocked all other threads of its processes are blocked",
            "Kernel level threads cannot utilize multiprocessor systems by splitting threads on different processors or cores"
        ],
        "correct_option": "Kernel level threads cannot utilize multiprocessor systems by splitting threads on different processors or cores"
    },
    {
        "topic": "Process Management",
        "question_no": "Question55",
        "question_text": "User level threads are threads that are visible to the programmer and are unknown to the kernel. The operating system kernel supports and manages kernel level threads. Three different types of models relate user and kernel level threads. Which of the following statements is/are true ?(a)(i) The Many - to - one model maps many user threads to one kernel thread (ii) The one - to - one model maps one user thread to one kernel thread (iii) The many - to - many model maps many user threads to smaller or equal kernel threads(b)(i) Many - to - one model maps many kernel threads to one user thread (ii) One - to - one model maps one kernel thread to one user thread (iii) Many - to - many model maps many kernel threads to smaller or equal user threads",
        "question_img_link": null,
        "options": [
            "(a) is true; (b) is false",
            "(a) is false; (b) is true",
            "Both (a) and (b) are true",
            "Both (a) and (b) are false"
        ],
        "correct_option": "(a) is true; (b) is false"
    },
    {
        "topic": "Process Management",
        "question_no": "Question56",
        "question_text": "The Bounded buffer problem is also known as __________.",
        "question_img_link": null,
        "options": [
            "Producer - consumer problem",
            "Reader - writer problem",
            "Dining Philosophers problem",
            "Both (2) and (3)"
        ],
        "correct_option": "Producer - consumer problem"
    },
    {
        "topic": "Process Management",
        "question_no": "Question57",
        "question_text": "What is the output of the following program?main( )\r\n{\r\nint a = 10;\r\nif ((fork ( ) == 0))\r\na++;\r\nprintf (“%d\\\\n”, a );\r\n}",
        "question_img_link": null,
        "options": [
            "10 and 11",
            "10",
            "11",
            "11 and 11"
        ],
        "correct_option": "10 and 11"
    },
    {
        "topic": "Process Management",
        "question_no": "Question58",
        "question_text": "Mutual exclusion problem occurs",
        "question_img_link": null,
        "options": [
            "Between two disjoint processes that do not interact",
            "Among processes that share resources",
            "Among processes that do not use the same resource",
            "Between two processes that uses different resources of different machine"
        ],
        "correct_option": "Among processes that share resources"
    },
    {
        "topic": "Process Management",
        "question_no": "Question59",
        "question_text": "A critical region",
        "question_img_link": null,
        "options": [
            "is a piece of code which only one process executes at a time",
            "is a region prone to deadlock",
            "is a piece of code which only a finite number of processes execute",
            "is found only in windows NT operating system"
        ],
        "correct_option": "is a piece of code which only one process executes at a time"
    },
    {
        "topic": "Process Management",
        "question_no": "Question60",
        "question_text": "At particular time, the value of a counting semaphore is 10, it will become 7 after:\r\n(a) 3 V operations\r\n(b) 3 P operations\r\n(c) 5 V operations and 2 P operations \r\n(d) 2 V operations and 5 P operations\r\nWhich of the following option is correct?",
        "question_img_link": null,
        "options": [
            "Only (b)",
            "Only(d)",
            "Both (b) and (d)",
            "None of these"
        ],
        "correct_option": "Both (b) and (d)"
    },
    {
        "topic": "Process Management",
        "question_no": "Question61",
        "question_text": "There are three processes P1, P2and P3sharing a semaphore for synchronizing a variable. Initial value of semaphore is one. Assume that negative value of semaphore tells us how many processes are waiting in queue. Processes access the semaphore in following order :\r\n (a) P2needs to access\r\n (b) P1needs to access\r\n (c) P3needs to access\r\n (d) P2exits critical section\r\n (e) P1exits critical section\r\n The final value of semaphore will be :",
        "question_img_link": null,
        "options": [
            "0",
            "1",
            "-1",
            "-2"
        ],
        "correct_option": "0"
    },
    {
        "topic": "Process Management",
        "question_no": "Question62",
        "question_text": "At a particular time of computation the value of a counting semaphore is 7. Then 20 P operations and xV operations were completed on this semaphore. If the new value of semaphore is 5 ,x will be",
        "question_img_link": null,
        "options": [
            "18",
            "22",
            "15",
            "13"
        ],
        "correct_option": "18"
    },
    {
        "topic": "Process Management",
        "question_no": "Question63",
        "question_text": "One of the disadvantages of user level threads compared to Kernel level threads is",
        "question_img_link": null,
        "options": [
            "If a user-level thread of a process executes a system call, all threads in that process are blocked.",
            "Scheduling is application dependent.",
            "Thread switching doesn’t require kernel mode privileges.",
            "The library procedures invoked for thread management in user level threads are local procedures."
        ],
        "correct_option": "If a user-level thread of a process executes a system call, all threads in that process are blocked."
    },
    {
        "topic": "Process Management",
        "question_no": "Question64",
        "question_text": "Names of some of the Operating Systems are given below:\r\n(a) MS-DOS \r\n(b) XENIX\r\n(c) OS/2\r\nIn the above list, following operating systems didn’t provide multiuser facility.",
        "question_img_link": null,
        "options": [
            "(a) only",
            "(a) and (b) only",
            "(b) and (c) only",
            "(a), (b) and (c)"
        ],
        "correct_option": "(a), (b) and (c)"
    },
    {
        "topic": "Process Management",
        "question_no": "Question65",
        "question_text": "In a lottery scheduler with 40 tickets, how we will distribute the tickets among 4 processes and such that each process gets 10%, 5%, 60% and 25% respectively?P1   P2   P3   P4\r\na)   12   4    70   30\r\nb)   7    5    20   10\r\nc)   4    2    24   10\r\nd)   8    5    40   30",
        "question_img_link": null,
        "options": [
            "a",
            "b",
            "c",
            "d"
        ],
        "correct_option": "c"
    },
    {
        "topic": "Process Management",
        "question_no": "Question66",
        "question_text": "Suppose a system contains n processes and system uses the round-robin algorithm for CPU scheduling then which data structure is best suited for ready queue of the process",
        "question_img_link": null,
        "options": [
            "stack",
            "queue",
            "circular queue",
            "tree"
        ],
        "correct_option": "circular queue"
    },
    {
        "topic": "Process Management",
        "question_no": "Question67",
        "question_text": "Consider a system with seven processes A through G and six resources R through W.\r\nResource ownership is as follows :\r\nprocess A holds R and wants T\r\nprocess B holds nothing but wants T\r\nprocess C holds nothing but wants S\r\nprocess D holds U and wants S & T\r\nprocess E holds T and wants V\r\nprocess F holds W and wants S\r\nprocess G holds V and wants U\r\nIs the system deadlocked ? If yes, ______ processes are deadlocked.",
        "question_img_link": null,
        "options": [
            "No",
            "Yes, A, B, C",
            "Yes, D, E, G",
            "Yes, A, B, F"
        ],
        "correct_option": "Yes, D, E, G"
    },
    {
        "topic": "Process Management",
        "question_no": "Question68",
        "question_text": "Consider a system having ‘m’ resources of the same type. These resources are shared by three processes P1, P2and P3which have peak demands of 2, 5 and 7 resources respectively. For what value of ‘m’ deadlock will not occur ?",
        "question_img_link": null,
        "options": [
            "70",
            "14",
            "13",
            "7"
        ],
        "correct_option": "14"
    },
    {
        "topic": "Process Management",
        "question_no": "Question69",
        "question_text": "An Operating System (OS) crashes on the average once in 30 days, that is, the Mean Time Between Failures (MTBF) = 30 days. When this happens, it takes 10 minutes to recover the OS, that is, the Mean Time To Repair (MTTR) = 10 minutes. The availability of the OS with these reliability figures is approximately :",
        "question_img_link": null,
        "options": [
            "96.97%",
            "97.97%",
            "99.009%",
            "99.97%"
        ],
        "correct_option": "99.97%"
    },
    {
        "topic": "Process Management",
        "question_no": "Question70",
        "question_text": "Suppose there are four processes in execution with 12 instances of a Resource R in a system.\r\nThe maximum need of each process and current allocation are given below:With reference to current allocation, is system safe ? If so, what is the safe sequence ?",
        "question_img_link": "https://www.cdn.geeksforgeeks.org/wp-content/uploads/37-2-1.png",
        "options": [
            "No",
            "Yes, P1P2P3P4",
            "Yes, P4P3P1P2",
            "Yes, P2P1P3P4"
        ],
        "correct_option": "Yes, P4P3P1P2"
    },
    {
        "topic": "Process Management",
        "question_no": "Question71",
        "question_text": "Consider the following set of processes, with arrival times and the required CPU-burst times given in milliseconds.Process  Arrival Time  Burst TimeP1        0             4\r\n   P2        2             2\r\n   P3        3             1What is the sequence in which the processes are completed? Assume round robin scheduling with a time quantum of 2 milliseconds",
        "question_img_link": null,
        "options": [
            "P1, P2, P3",
            "P2, P1, P3",
            "P3, P2, P1",
            "P2, P3, P1"
        ],
        "correct_option": "P2, P1, P3"
    },
    {
        "topic": "Process Management",
        "question_no": "Question72",
        "question_text": "A CPU scheduling algorithm determines an order for the execution of its scheduled processes. Given 'n' processes to be scheduled on one processor, how many possible different schedules are there?",
        "question_img_link": null,
        "options": [
            "n",
            "n2",
            "n!",
            "2n"
        ],
        "correct_option": "n!"
    },
    {
        "topic": "Process Management",
        "question_no": "Question73",
        "question_text": "A starvation free job scheduling policy guarantees that no job indefinitely waits for a service. Which of the following job scheduling policies is starvation free?",
        "question_img_link": null,
        "options": [
            "Priority queuing",
            "Shortest Job First",
            "Youngest Job First",
            "Round robin"
        ],
        "correct_option": "Round robin"
    },
    {
        "topic": "Process Management",
        "question_no": "Question74",
        "question_text": "The state of a process after it encounters an I/O instruction is",
        "question_img_link": null,
        "options": [
            "ready",
            "blocked",
            "idle",
            "running"
        ],
        "correct_option": "blocked"
    },
    {
        "topic": "Process Management",
        "question_no": "Question75",
        "question_text": "Which of the following strategy is employed for overcoming the priority inversion problem?",
        "question_img_link": null,
        "options": [
            "Temporarily raise the priority of lower priority level process",
            "Have a fixed priority level scheme",
            "Implement kernel pre-emption scheme",
            "Allow lower priority process to complete its job"
        ],
        "correct_option": "Temporarily raise the priority of lower priority level process"
    },
    {
        "topic": "Process Management",
        "question_no": "Question76",
        "question_text": "System calls are usually invoked by using :",
        "question_img_link": null,
        "options": [
            "A privileged instruction",
            "An indirect jump",
            "A software interrupt",
            "Polling"
        ],
        "correct_option": "A software interrupt"
    },
    {
        "topic": "Process Management",
        "question_no": "Question77",
        "question_text": "A disk drive has 100 cylinders, numbered 0 to 99. Disk requests come to the disk driver for cylinders 12, 26, 24, 4, 42, 8 and 50 in that order. The driver is currently serving a request at cylinder 24. A seek takes 6 msec per cylinder moved. How much seek time is needed for shortest seek time first (SSTF) algorithm?",
        "question_img_link": null,
        "options": [
            "0.984 sec",
            "0.396 sec",
            "0.738 sec",
            "0.42 sec"
        ],
        "correct_option": "0.42 sec"
    },
    {
        "topic": "Process Management",
        "question_no": "Question78",
        "question_text": "The following table shows the processes in the ready queue and time required for each process for completing its job.Process    TimeP1          10\r\nP2          5\r\nP3          20\r\nP4          8\r\nP5          15If round-robin scheduling with 5 ms is used what is the average waiting time of the processes in the queue?",
        "question_img_link": null,
        "options": [
            "27 ms",
            "26.2 ms",
            "27.5 ms",
            "27.2 ms"
        ],
        "correct_option": "26.2 ms"
    },
    {
        "topic": "Process Management",
        "question_no": "Question79",
        "question_text": "Consider a system with twelve magnetic tape drives and three processes P1, P2and P3. Process P1requires maximum ten tape drives, process P2may need as many as four tape drives and P3may need upto nine tape drives. Suppose that at time t1, process P1is holding five tape drives, process P2is holding two tape drives and process P3is holding three tape drives. At time t1, system is in:",
        "question_img_link": null,
        "options": [
            "safe state",
            "unsafe state",
            "deadlocked state",
            "starvation state"
        ],
        "correct_option": "unsafe state"
    },
    {
        "topic": "Process Management",
        "question_no": "Question80",
        "question_text": "In an operating system, indivisibility of operation means:",
        "question_img_link": null,
        "options": [
            "Operation is interruptible",
            "Race - condition may occur",
            "Processor can not be pre-empted",
            "All of the above"
        ],
        "correct_option": "Processor can not be pre-empted"
    },
    {
        "topic": "Process Management",
        "question_no": "Question81",
        "question_text": "There are three processes in the ready queue. When the currently running process requests for I/O how many process switches take place?",
        "question_img_link": null,
        "options": [
            "1",
            "2",
            "3",
            "4"
        ],
        "correct_option": "1"
    },
    {
        "topic": "Process Management",
        "question_no": "Question82",
        "question_text": "Which is the correct definition of a valid process transition in an operating system?",
        "question_img_link": null,
        "options": [
            "Wake up: ready → running",
            "Dispatch: ready → running",
            "Block: ready → running",
            "Timer runout: ready → running"
        ],
        "correct_option": "Dispatch: ready → running"
    },
    {
        "topic": "Process Management",
        "question_no": "Question83",
        "question_text": "The correct matching of the following pairs is(A) Disk check              (1) Roundrobin\r\n(B) Batch processing        (2) Scan\r\n(C) Time sharing            (3) LIFO\r\n(D) Stack operation         (4) FIFO",
        "question_img_link": null,
        "options": [
            "A B C D\r\n 3 4 2 1",
            "A B C D\r\n4 3 2 1",
            "A B C D\r\n3 4 1 2",
            "A B C D\r\n2 4 1 3"
        ],
        "correct_option": "A B C D\n2 4 1 3"
    },
    {
        "topic": "Process Management",
        "question_no": "Question84",
        "question_text": "Consider three CPU-intensive processes, which require 10, 20 and 30 time units and arrive at times 0, 2 and 6, respectively. How many context switches are needed if the operating system implements a shortest remaining time first scheduling algorithm?\r\nDo not count the context switches at time zero and at the end.",
        "question_img_link": null,
        "options": [
            "1",
            "2",
            "3",
            "4"
        ],
        "correct_option": "2"
    },
    {
        "topic": "Process Management",
        "question_no": "Question85",
        "question_text": "The performance of Round Robin algorithm depends heavily on",
        "question_img_link": null,
        "options": [
            "size of the process",
            "the I/O bursts of the process",
            "the CPU bursts of the process",
            "the size of the time quantum"
        ],
        "correct_option": "the size of the time quantum"
    },
    {
        "topic": "Process Management",
        "question_no": "Question86",
        "question_text": "Consider a set of 5 processes whose arrival time, CPU time needed and the priority are given below:Process       Arrival Time   CPU Time Needed     Priority(in ms)\r\n\r\nP1              0             10                 5\r\nP2              0             5                  2\r\nP3              2             3                  1\r\nP4              5             20                 4\r\nP5              10            2                  3(smaller the number, higher the priority)\r\nIf the CPU scheduling policy is priority scheduling without preemption, the average waiting time will be",
        "question_img_link": null,
        "options": [
            "12.8 ms",
            "11.8 ms",
            "10.8 ms",
            "9.8 ms"
        ],
        "correct_option": "10.8 ms"
    },
    {
        "topic": "Process Management",
        "question_no": "Question87",
        "question_text": "Process is:",
        "question_img_link": null,
        "options": [
            "A program in high level language kept on disk",
            "Contents of main memory",
            "A program in execution",
            "A job in secondary memory"
        ],
        "correct_option": "A program in execution"
    },
    {
        "topic": "Process Management",
        "question_no": "Question88",
        "question_text": "Four jobs to be executed on a single processor system arrive at time 0 in the order A, B, C, D . Their burst CPU time requirements are 4, 1, 8, 1 time units respectively. The completion time of A under round robin scheduling with time slice of one time unit is",
        "question_img_link": null,
        "options": [
            "10",
            "4",
            "8",
            "9"
        ],
        "correct_option": "9"
    },
    {
        "topic": "Process Management",
        "question_no": "Question89",
        "question_text": "Which of the following need not necessarily be saved on a context switch between processes?",
        "question_img_link": null,
        "options": [
            "General purpose registers",
            "Translation look-aside buffer",
            "Program counter",
            "All of the above"
        ],
        "correct_option": "Translation look-aside buffer"
    },
    {
        "topic": "Process Management",
        "question_no": "Question90",
        "question_text": "With Round-Robin CPU scheduling in a time shared system",
        "question_img_link": null,
        "options": [
            "using very large time slices (quantas) degenerates into FirstCome First served (FCFS) algorithm.",
            "using extremely small time slices improves performance",
            "using very small time slices degenerates into Last-In First-Out (LIFO) algorithm.",
            "using medium sized times slices leads to shortest Request time First (SRTF) algorithm"
        ],
        "correct_option": "using very large time slices (quantas) degenerates into FirstCome First served (FCFS) algorithm."
    },
    {
        "topic": "Process Management",
        "question_no": "Question91",
        "question_text": "What is the name of the operating system that reads and reacts in terms of operating system?",
        "question_img_link": null,
        "options": [
            "Batch system",
            "Quick response time",
            "real time system",
            "Time sharing system"
        ],
        "correct_option": "real time system"
    },
    {
        "topic": "Process Management",
        "question_no": "Question92",
        "question_text": "Fork is",
        "question_img_link": null,
        "options": [
            "the creation of a new job",
            "the dispatching of a task",
            "increasing the priority of a task",
            "the creation of a new process"
        ],
        "correct_option": "the creation of a new process"
    },
    {
        "topic": "Process Management",
        "question_no": "Question93",
        "question_text": "Which of the following need not necessarily be saved on a Context Switch between processes?",
        "question_img_link": null,
        "options": [
            "General purpose registers",
            "Translation look-aside buffer",
            "Program counter",
            "Stack pointer"
        ],
        "correct_option": "Translation look-aside buffer"
    },
    {
        "topic": "Process Management",
        "question_no": "Question94",
        "question_text": "The performance of Round Robin algorithm depends heavily on",
        "question_img_link": null,
        "options": [
            "size of the process",
            "the I/O bursts of the process",
            "the CPU bursts of the process",
            "the size of the time quantum"
        ],
        "correct_option": "the size of the time quantum"
    },
    {
        "topic": "Process Management",
        "question_no": "Question95",
        "question_text": "Match the following:",
        "question_img_link": null,
        "options": [],
        "correct_option": "(2)"
    },
    {
        "topic": "Process Management",
        "question_no": "Question96",
        "question_text": "Dining Philosopher's problem is a:",
        "question_img_link": null,
        "options": [
            "Producer - consumer problem",
            "Classical IPC problem",
            "Starvation problem",
            "Synchronization primitive"
        ],
        "correct_option": "Classical IPC problem"
    },
    {
        "topic": "Process Management",
        "question_no": "Question97",
        "question_text": "Consider a set of n tasks with known runtimes r1, r2....rnto be run on a uniprocessor machine. Which of the following processor scheduling algorithms will result in the maximum throughput?",
        "question_img_link": null,
        "options": [
            "Round Robin",
            "Shortest job first",
            "Highest response ratio next",
            "first come first served"
        ],
        "correct_option": "Shortest job first"
    },
    {
        "topic": "Process Management",
        "question_no": "Question98",
        "question_text": "Round Robin schedule is essentially the pre-emptive version of",
        "question_img_link": null,
        "options": [
            "FIFO",
            "Shortest job first",
            "Shortest remaining time",
            "Longest remaining time"
        ],
        "correct_option": "FIFO"
    },
    {
        "topic": "Process Management",
        "question_no": "Question99",
        "question_text": "What is the name of the technique in which the operating system of a computer executes several programs concurrently by switching back and forth between them?",
        "question_img_link": null,
        "options": [
            "Partitioning",
            "Multi-tasking",
            "Windowing",
            "Paging"
        ],
        "correct_option": "Multi-tasking"
    },
    {
        "topic": "Process Management",
        "question_no": "Question100",
        "question_text": "A task in a blocked state",
        "question_img_link": null,
        "options": [
            "is executable",
            "is running",
            "must still be placed in the run queues",
            "is waiting for some temporarily unavailable resources"
        ],
        "correct_option": "is waiting for some temporarily unavailable resources"
    },
    {
        "topic": "Process Management",
        "question_no": "Question101",
        "question_text": "On a system using non-preemptive scheduling, processes with expected run times of 5, 18, 9 and 12 are in the ready queue. In what order should they be run to minimize wait time?",
        "question_img_link": null,
        "options": [
            "5, 12, 9, 18",
            "5, 9, 12, 18",
            "12, 18, 9, 5",
            "9, 12, 18, 5"
        ],
        "correct_option": "5, 9, 12, 18"
    },
    {
        "topic": "Process Management",
        "question_no": "Question102",
        "question_text": "Feedback queues",
        "question_img_link": null,
        "options": [
            "are very simple to implement",
            "dispatch tasks according to execution characteristics",
            "are used to favour real time tasks",
            "require manual intervention to implement properly"
        ],
        "correct_option": "dispatch tasks according to execution characteristics"
    },
    {
        "topic": "Process Management",
        "question_no": "Question103",
        "question_text": "Which of the following conditions does not hold good for a solution to a critical section problem ?",
        "question_img_link": null,
        "options": [
            "No assumptions may be made about speeds or the number of CPUs.",
            "No two processes may be simultaneously inside their critical sections.",
            "Processes running outside its critical section may block other processes.",
            "Processes do not wait forever to enter its critical section."
        ],
        "correct_option": "Processes running outside its critical section may block other processes."
    },
    {
        "topic": "Process Management",
        "question_no": "Question104",
        "question_text": "For switching from a CPU user mode to the supervisor mode following type of interrupt is most appropriate",
        "question_img_link": null,
        "options": [
            "Internal interrupts",
            "External interrupts",
            "Software interrupts",
            "None of the above"
        ],
        "correct_option": "Software interrupts"
    },
    {
        "topic": "Process Management",
        "question_no": "Question105",
        "question_text": "In a dot matrix printer the time to print a character is 6 m.sec., time to space in between characters is 2 m.sec., and the number of characters in a line are 200. The printing speed\r\nof the dot matrix printer in characters per second and the time to print a character line are given by which of the following options?",
        "question_img_link": null,
        "options": [
            "125 chars/second and 0.8 seconds",
            "250 chars/second and 0.6 seconds",
            "166 chars/second and 0.8 seconds",
            "250 chars/second and 0.4 seconds",
            "125 chars/second and 1.6 seconds"
        ],
        "correct_option": "125 chars/second and 1.6 seconds"
    },
    {
        "topic": "Process Management",
        "question_no": "Question106",
        "question_text": "Monitor is an Interprocess Communication (IPC) technique which can be described as",
        "question_img_link": null,
        "options": [
            "It is higher level synchronization primitive and is a collection of procedures, variables, and data structures grouped together in a special package.",
            "It is a non-negative integer which apart from initialization can be acted upon by wait and signal operations.",
            "It uses two primitives, send and receive which are system calls rather than language constructs.",
            "It consists of the IPC primitives implemented as system calls to block the process when they are not allowed to enter critical region to save CPU time."
        ],
        "correct_option": "It is higher level synchronization primitive and is a collection of procedures, variables, and data structures grouped together in a special package."
    },
    {
        "topic": "Process Management",
        "question_no": "Question107",
        "question_text": "The following C programmain()\r\n{\r\n    fork() ; fork() ; printf (\"yes\");\r\n}If we execute this core segment, how many times the string yes will be printed ?",
        "question_img_link": null,
        "options": [
            "Only once",
            "2 times",
            "4 times",
            "8 times"
        ],
        "correct_option": "4 times"
    },
    {
        "topic": "Process Management",
        "question_no": "Question108",
        "question_text": "Here are the two concurrent process P1, P2with respective codes:\r\nP1code:while (true) // infinite condition\r\n{\r\nA :____;\r\nprintf(\"%d\", 1);\r\nprintf(\"%d\", 1);\r\nB:____;\r\n}P2code:while (true) // infinite condition\r\n{\r\nC:____;\r\nprintf(\"%d\", 0);\r\nprintf(\"%d\", 0);\r\nD:____;\r\n}What should be the binary semaphore operation on A,B,C,D respectively and what must be the intial values of semaphore M,N inorder to get the output 110011001100....?\r\nWhere P is down and V is up operation respectively.",
        "question_img_link": null,
        "options": [
            "A = P(N), B = V(M), C = P(M), D = V(N); M = 0, N = 1;",
            "A = P(N), B = V(M), C = P(M), D = P(N); M =  N = 1;",
            "A = P(N), B = V(N), C = P(M), D = V(M); M = 1, N = 0;",
            "A = P(N), B = V(N), C = P(M), D = V(M); M =  N = 1;"
        ],
        "correct_option": "A = P(N), B = V(M), C = P(M), D = V(N); M = 0, N = 1;"
    },
    {
        "topic": "Process Management",
        "question_no": "Question109",
        "question_text": "At a particular time of computation, the value of a counting semaphore is 10. Then 12 P operations and “x” V operations were performed on this semaphore. If the final value of semaphore is 7, x will be:",
        "question_img_link": null,
        "options": [
            "8",
            "9",
            "10",
            "11"
        ],
        "correct_option": "9"
    },
    {
        "topic": "Process Management",
        "question_no": "Question110",
        "question_text": "Consider the following statements about process state transitions for a system using preemptive scheduling.I.A running process can move to ready state.II.A ready process can move to running state.III.A blocked process can move to running state.IV.A blocked process can move to ready state.Which of the above statements are TRUE ?",
        "question_img_link": null,
        "options": [
            "I.A running process can move to ready state.",
            "II.A ready process can move to running state.",
            "III.A blocked process can move to running state.",
            "IV.A blocked process can move to ready state.",
            "I, II, and III only",
            "II and III only",
            "I, II, and IV only",
            "I, II, III and IV only"
        ],
        "correct_option": "null"
    }
]